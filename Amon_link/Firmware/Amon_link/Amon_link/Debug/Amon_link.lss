
Amon_link.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000072f  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000ce  00000000  00000000  000000d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800100  00800100  0000072f  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  0000072f  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000001c  00000000  00000000  0000075e  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000118  00000000  00000000  0000077a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d27  00000000  00000000  00000892  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ab0  00000000  00000000  000025b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a06  00000000  00000000  00003069  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002b8  00000000  00000000  00003a70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000275  00000000  00000000  00003d28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000876  00000000  00000000  00003f9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00004813  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  0000064c  0000064c  00000720  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000048ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.GPIO_PIN_Write 000000a8  000001e4  000001e4  000002b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.GPIO_PIN_Toggle 0000004e  0000051a  0000051a  000005ee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.__vector_11 0000009e  00000334  00000334  00000408  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.IRQ_Timer1_Init 00000028  000005a0  000005a0  00000674  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.DeviceInit 00000064  00000466  00000466  0000053a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .progmemx.data 00000022  000000ce  000000ce  000001a2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 21 .text.main    000000a8  0000028c  0000028c  00000360  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.__vector_1 00000018  000005e2  000005e2  000006b6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .bss.Pair_Status 00000001  00800166  00800166  0000072f  2**0
                  ALLOC
 24 .bss.PairTrig 00000001  00800167  00800167  0000072f  2**0
                  ALLOC
 25 .bss.PairTime 00000001  00800168  00800168  0000072f  2**0
                  ALLOC
 26 .bss.InitOK   00000001  00800169  00800169  0000072f  2**0
                  ALLOC
 27 .bss.InitTime 00000001  0080016a  0080016a  0000072f  2**0
                  ALLOC
 28 .data.InitError 00000001  0080016b  0000065a  0000072e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 29 .text.SPI_Init 00000006  00000646  00000646  0000071a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.SPI_Transmit 0000000c  0000063a  0000063a  0000070e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.SPI_test 00000050  000004ca  000004ca  0000059e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.USART_Init 00000016  000005fa  000005fa  000006ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.__vector_20 00000014  00000626  00000626  000006fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.USART_DATA_Transmit 00000038  00000568  00000568  0000063c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.USART_RX_DATA_Decode 000000f4  000000f0  000000f0  000001c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.__vector_18 00000094  000003d2  000003d2  000004a6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .bss.USART_DATA_RAW_Recieve 00000064  00800102  00800102  0000072f  2**0
                  ALLOC
 38 .bss.Data_Count 00000001  0080016c  0080016c  0000072f  2**0
                  ALLOC
 39 .text.libgcc  0000001a  000005c8  000005c8  0000069c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.__dummy_fini 00000002  00000654  00000654  00000728  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.__dummy_funcs_on_exit 00000002  00000656  00000656  0000072a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.__dummy_simulator_exit 00000002  00000658  00000658  0000072c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.exit    00000016  00000610  00000610  000006e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text._Exit   00000004  00000650  00000650  00000724  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3d 00 	jmp	0x7a	; 0x7a <__ctors_end>
   4:	0c 94 f1 02 	jmp	0x5e2	; 0x5e2 <__vector_1>
   8:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
   c:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  10:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  14:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  18:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  1c:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  20:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  24:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  28:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  2c:	0c 94 9a 01 	jmp	0x334	; 0x334 <__vector_11>
  30:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  34:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  38:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  3c:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  40:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  44:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  48:	0c 94 e9 01 	jmp	0x3d2	; 0x3d2 <__vector_18>
  4c:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  50:	0c 94 13 03 	jmp	0x626	; 0x626 <__vector_20>
  54:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  58:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  5c:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  60:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>
  64:	0c 94 26 03 	jmp	0x64c	; 0x64c <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 6b       	ori	r16, 0xB1	; 177
  6c:	80 01       	movw	r16, r0
  6e:	6b 01       	movw	r12, r22
  70:	6c 00       	.word	0x006c	; ????
  72:	06 5a       	subi	r16, 0xA6	; 166
  74:	01 6c       	ori	r16, 0xC1	; 193
  76:	01 6d       	ori	r16, 0xD1	; 209
  78:	80 00       	.word	0x0080	; ????

0000007a <__ctors_end>:
  7a:	11 24       	eor	r1, r1
  7c:	1f be       	out	0x3f, r1	; 63
  7e:	cf ef       	ldi	r28, 0xFF	; 255
  80:	d8 e0       	ldi	r29, 0x08	; 8
  82:	de bf       	out	0x3e, r29	; 62
  84:	cd bf       	out	0x3d, r28	; 61

00000086 <__do_copy_data>:
  86:	e8 e6       	ldi	r30, 0x68	; 104
  88:	f0 e0       	ldi	r31, 0x00	; 0
  8a:	40 e0       	ldi	r20, 0x00	; 0
  8c:	17 c0       	rjmp	.+46     	; 0xbc <__do_clear_bss+0x8>
  8e:	b5 91       	lpm	r27, Z+
  90:	a5 91       	lpm	r26, Z+
  92:	35 91       	lpm	r19, Z+
  94:	25 91       	lpm	r18, Z+
  96:	05 91       	lpm	r16, Z+
  98:	07 fd       	sbrc	r16, 7
  9a:	0c c0       	rjmp	.+24     	; 0xb4 <__do_clear_bss>
  9c:	95 91       	lpm	r25, Z+
  9e:	85 91       	lpm	r24, Z+
  a0:	ef 01       	movw	r28, r30
  a2:	f9 2f       	mov	r31, r25
  a4:	e8 2f       	mov	r30, r24
  a6:	05 90       	lpm	r0, Z+
  a8:	0d 92       	st	X+, r0
  aa:	a2 17       	cp	r26, r18
  ac:	b3 07       	cpc	r27, r19
  ae:	d9 f7       	brne	.-10     	; 0xa6 <__do_copy_data+0x20>
  b0:	fe 01       	movw	r30, r28
  b2:	04 c0       	rjmp	.+8      	; 0xbc <__do_clear_bss+0x8>

000000b4 <__do_clear_bss>:
  b4:	1d 92       	st	X+, r1
  b6:	a2 17       	cp	r26, r18
  b8:	b3 07       	cpc	r27, r19
  ba:	e1 f7       	brne	.-8      	; 0xb4 <__do_clear_bss>
  bc:	e9 37       	cpi	r30, 0x79	; 121
  be:	f4 07       	cpc	r31, r20
  c0:	31 f7       	brne	.-52     	; 0x8e <__do_copy_data+0x8>
  c2:	0e 94 46 01 	call	0x28c	; 0x28c <main>
  c6:	0c 94 08 03 	jmp	0x610	; 0x610 <exit>

000000ca <_exit>:
  ca:	f8 94       	cli

000000cc <__stop_program>:
  cc:	ff cf       	rjmp	.-2      	; 0xcc <__stop_program>

Disassembly of section .text:

0000064c <__bad_interrupt>:
 64c:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.GPIO_PIN_Write:

000001e4 <GPIO_PIN_Write>:
}

/* Set pin to high/low */
void GPIO_PIN_Write(char port, uint8_t pinNum, char state){
	
	switch(port){
 1e4:	82 30       	cpi	r24, 0x02	; 2
 1e6:	f9 f0       	breq	.+62     	; 0x226 <GPIO_PIN_Write+0x42>
 1e8:	83 30       	cpi	r24, 0x03	; 3
 1ea:	b9 f1       	breq	.+110    	; 0x25a <GPIO_PIN_Write+0x76>
 1ec:	81 30       	cpi	r24, 0x01	; 1
 1ee:	09 f0       	breq	.+2      	; 0x1f2 <GPIO_PIN_Write+0xe>
 1f0:	4c c0       	rjmp	.+152    	; 0x28a <GPIO_PIN_Write+0xa6>
		case 1:
			(state) ? (PORTB |= (1 << pinNum)) : (PORTB &= ~(1 << pinNum));
 1f2:	44 23       	and	r20, r20
 1f4:	61 f0       	breq	.+24     	; 0x20e <GPIO_PIN_Write+0x2a>
 1f6:	25 b1       	in	r18, 0x05	; 5
 1f8:	81 e0       	ldi	r24, 0x01	; 1
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	06 2e       	mov	r0, r22
 1fe:	02 c0       	rjmp	.+4      	; 0x204 <GPIO_PIN_Write+0x20>
 200:	88 0f       	add	r24, r24
 202:	99 1f       	adc	r25, r25
 204:	0a 94       	dec	r0
 206:	e2 f7       	brpl	.-8      	; 0x200 <GPIO_PIN_Write+0x1c>
 208:	82 2b       	or	r24, r18
 20a:	85 b9       	out	0x05, r24	; 5
 20c:	0c c0       	rjmp	.+24     	; 0x226 <GPIO_PIN_Write+0x42>
 20e:	25 b1       	in	r18, 0x05	; 5
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	06 2e       	mov	r0, r22
 216:	02 c0       	rjmp	.+4      	; 0x21c <GPIO_PIN_Write+0x38>
 218:	88 0f       	add	r24, r24
 21a:	99 1f       	adc	r25, r25
 21c:	0a 94       	dec	r0
 21e:	e2 f7       	brpl	.-8      	; 0x218 <GPIO_PIN_Write+0x34>
 220:	80 95       	com	r24
 222:	82 23       	and	r24, r18
 224:	85 b9       	out	0x05, r24	; 5
		case 2:
			(state) ? (PORTC |= (1 << pinNum)) : (PORTC &= ~(1 << pinNum));
 226:	44 23       	and	r20, r20
 228:	61 f0       	breq	.+24     	; 0x242 <GPIO_PIN_Write+0x5e>
 22a:	28 b1       	in	r18, 0x08	; 8
 22c:	81 e0       	ldi	r24, 0x01	; 1
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	06 2e       	mov	r0, r22
 232:	02 c0       	rjmp	.+4      	; 0x238 <GPIO_PIN_Write+0x54>
 234:	88 0f       	add	r24, r24
 236:	99 1f       	adc	r25, r25
 238:	0a 94       	dec	r0
 23a:	e2 f7       	brpl	.-8      	; 0x234 <GPIO_PIN_Write+0x50>
 23c:	82 2b       	or	r24, r18
 23e:	88 b9       	out	0x08, r24	; 8
 240:	0c c0       	rjmp	.+24     	; 0x25a <GPIO_PIN_Write+0x76>
 242:	28 b1       	in	r18, 0x08	; 8
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	06 2e       	mov	r0, r22
 24a:	02 c0       	rjmp	.+4      	; 0x250 <GPIO_PIN_Write+0x6c>
 24c:	88 0f       	add	r24, r24
 24e:	99 1f       	adc	r25, r25
 250:	0a 94       	dec	r0
 252:	e2 f7       	brpl	.-8      	; 0x24c <GPIO_PIN_Write+0x68>
 254:	80 95       	com	r24
 256:	82 23       	and	r24, r18
 258:	88 b9       	out	0x08, r24	; 8
		case 3:
			(state) ? (PORTD |= (1 << pinNum)) : (PORTD &= ~(1 << pinNum));
 25a:	44 23       	and	r20, r20
 25c:	59 f0       	breq	.+22     	; 0x274 <GPIO_PIN_Write+0x90>
 25e:	2b b1       	in	r18, 0x0b	; 11
 260:	81 e0       	ldi	r24, 0x01	; 1
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	02 c0       	rjmp	.+4      	; 0x26a <GPIO_PIN_Write+0x86>
 266:	88 0f       	add	r24, r24
 268:	99 1f       	adc	r25, r25
 26a:	6a 95       	dec	r22
 26c:	e2 f7       	brpl	.-8      	; 0x266 <GPIO_PIN_Write+0x82>
 26e:	82 2b       	or	r24, r18
 270:	8b b9       	out	0x0b, r24	; 11
 272:	08 95       	ret
 274:	2b b1       	in	r18, 0x0b	; 11
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	02 c0       	rjmp	.+4      	; 0x280 <GPIO_PIN_Write+0x9c>
 27c:	88 0f       	add	r24, r24
 27e:	99 1f       	adc	r25, r25
 280:	6a 95       	dec	r22
 282:	e2 f7       	brpl	.-8      	; 0x27c <GPIO_PIN_Write+0x98>
 284:	80 95       	com	r24
 286:	82 23       	and	r24, r18
 288:	8b b9       	out	0x0b, r24	; 11
 28a:	08 95       	ret

Disassembly of section .text.GPIO_PIN_Toggle:

0000051a <GPIO_PIN_Toggle>:
}

/* Toggle pin value */
void GPIO_PIN_Toggle(char port, uint8_t pinNum){
		
	switch(port){
 51a:	82 30       	cpi	r24, 0x02	; 2
 51c:	79 f0       	breq	.+30     	; 0x53c <GPIO_PIN_Toggle+0x22>
 51e:	83 30       	cpi	r24, 0x03	; 3
 520:	c1 f0       	breq	.+48     	; 0x552 <GPIO_PIN_Toggle+0x38>
 522:	81 30       	cpi	r24, 0x01	; 1
 524:	01 f5       	brne	.+64     	; 0x566 <GPIO_PIN_Toggle+0x4c>
		case 1:
			PORTB ^= (1 << pinNum);
 526:	25 b1       	in	r18, 0x05	; 5
 528:	81 e0       	ldi	r24, 0x01	; 1
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	06 2e       	mov	r0, r22
 52e:	02 c0       	rjmp	.+4      	; 0x534 <GPIO_PIN_Toggle+0x1a>
 530:	88 0f       	add	r24, r24
 532:	99 1f       	adc	r25, r25
 534:	0a 94       	dec	r0
 536:	e2 f7       	brpl	.-8      	; 0x530 <GPIO_PIN_Toggle+0x16>
 538:	82 27       	eor	r24, r18
 53a:	85 b9       	out	0x05, r24	; 5
		case 2:
			PORTC ^= (1 << pinNum);
 53c:	28 b1       	in	r18, 0x08	; 8
 53e:	81 e0       	ldi	r24, 0x01	; 1
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	06 2e       	mov	r0, r22
 544:	02 c0       	rjmp	.+4      	; 0x54a <GPIO_PIN_Toggle+0x30>
 546:	88 0f       	add	r24, r24
 548:	99 1f       	adc	r25, r25
 54a:	0a 94       	dec	r0
 54c:	e2 f7       	brpl	.-8      	; 0x546 <GPIO_PIN_Toggle+0x2c>
 54e:	82 27       	eor	r24, r18
 550:	88 b9       	out	0x08, r24	; 8
		case 3:
			PORTD ^= (1 << pinNum);
 552:	2b b1       	in	r18, 0x0b	; 11
 554:	81 e0       	ldi	r24, 0x01	; 1
 556:	90 e0       	ldi	r25, 0x00	; 0
 558:	02 c0       	rjmp	.+4      	; 0x55e <GPIO_PIN_Toggle+0x44>
 55a:	88 0f       	add	r24, r24
 55c:	99 1f       	adc	r25, r25
 55e:	6a 95       	dec	r22
 560:	e2 f7       	brpl	.-8      	; 0x55a <GPIO_PIN_Toggle+0x40>
 562:	82 27       	eor	r24, r18
 564:	8b b9       	out	0x0b, r24	; 11
 566:	08 95       	ret

Disassembly of section .text.__vector_11:

00000334 <__vector_11>:
	// Set detect on falling edge
	EICRA |= (1 << ISC01);
	EICRA &= ~(1 << ISC00);
	
	// enable int
	EIMSK |= (1 << INT0); 
 334:	1f 92       	push	r1
 336:	0f 92       	push	r0
 338:	0f b6       	in	r0, 0x3f	; 63
 33a:	0f 92       	push	r0
 33c:	11 24       	eor	r1, r1
 33e:	2f 93       	push	r18
 340:	3f 93       	push	r19
 342:	4f 93       	push	r20
 344:	5f 93       	push	r21
 346:	6f 93       	push	r22
 348:	7f 93       	push	r23
 34a:	8f 93       	push	r24
 34c:	9f 93       	push	r25
 34e:	af 93       	push	r26
 350:	bf 93       	push	r27
 352:	ef 93       	push	r30
 354:	ff 93       	push	r31
 356:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <InitOK>
 35a:	81 11       	cpse	r24, r1
 35c:	15 c0       	rjmp	.+42     	; 0x388 <__vector_11+0x54>
 35e:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <InitTime>
 362:	8e 31       	cpi	r24, 0x1E	; 30
 364:	50 f0       	brcs	.+20     	; 0x37a <__vector_11+0x46>
 366:	81 e0       	ldi	r24, 0x01	; 1
 368:	80 93 69 01 	sts	0x0169, r24	; 0x800169 <InitOK>
 36c:	10 92 6a 01 	sts	0x016A, r1	; 0x80016a <InitTime>
 370:	41 e0       	ldi	r20, 0x01	; 1
 372:	60 e0       	ldi	r22, 0x00	; 0
 374:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 378:	07 c0       	rjmp	.+14     	; 0x388 <__vector_11+0x54>
 37a:	8f 5f       	subi	r24, 0xFF	; 255
 37c:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <InitTime>
 380:	60 e0       	ldi	r22, 0x00	; 0
 382:	81 e0       	ldi	r24, 0x01	; 1
 384:	0e 94 8d 02 	call	0x51a	; 0x51a <GPIO_PIN_Toggle>
 388:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <PairTrig>
 38c:	81 30       	cpi	r24, 0x01	; 1
 38e:	81 f4       	brne	.+32     	; 0x3b0 <__vector_11+0x7c>
 390:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <PairTime>
 394:	8e 31       	cpi	r24, 0x1E	; 30
 396:	28 f0       	brcs	.+10     	; 0x3a2 <__vector_11+0x6e>
 398:	10 92 67 01 	sts	0x0167, r1	; 0x800167 <PairTrig>
 39c:	10 92 68 01 	sts	0x0168, r1	; 0x800168 <PairTime>
 3a0:	07 c0       	rjmp	.+14     	; 0x3b0 <__vector_11+0x7c>
 3a2:	8f 5f       	subi	r24, 0xFF	; 255
 3a4:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <PairTime>
 3a8:	60 e0       	ldi	r22, 0x00	; 0
 3aa:	81 e0       	ldi	r24, 0x01	; 1
 3ac:	0e 94 8d 02 	call	0x51a	; 0x51a <GPIO_PIN_Toggle>
 3b0:	ff 91       	pop	r31
 3b2:	ef 91       	pop	r30
 3b4:	bf 91       	pop	r27
 3b6:	af 91       	pop	r26
 3b8:	9f 91       	pop	r25
 3ba:	8f 91       	pop	r24
 3bc:	7f 91       	pop	r23
 3be:	6f 91       	pop	r22
 3c0:	5f 91       	pop	r21
 3c2:	4f 91       	pop	r20
 3c4:	3f 91       	pop	r19
 3c6:	2f 91       	pop	r18
 3c8:	0f 90       	pop	r0
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	0f 90       	pop	r0
 3ce:	1f 90       	pop	r1
 3d0:	18 95       	reti

Disassembly of section .text.IRQ_Timer1_Init:

000005a0 <IRQ_Timer1_Init>:
 5a0:	e1 e8       	ldi	r30, 0x81	; 129
 5a2:	f0 e0       	ldi	r31, 0x00	; 0
 5a4:	80 81       	ld	r24, Z
 5a6:	88 60       	ori	r24, 0x08	; 8
 5a8:	80 83       	st	Z, r24
 5aa:	88 ea       	ldi	r24, 0xA8	; 168
 5ac:	91 e6       	ldi	r25, 0x61	; 97
 5ae:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 5b2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 5b6:	af e6       	ldi	r26, 0x6F	; 111
 5b8:	b0 e0       	ldi	r27, 0x00	; 0
 5ba:	8c 91       	ld	r24, X
 5bc:	82 60       	ori	r24, 0x02	; 2
 5be:	8c 93       	st	X, r24
 5c0:	80 81       	ld	r24, Z
 5c2:	83 60       	ori	r24, 0x03	; 3
 5c4:	80 83       	st	Z, r24
 5c6:	08 95       	ret

Disassembly of section .text.DeviceInit:

00000466 <DeviceInit>:
 466:	84 b1       	in	r24, 0x04	; 4
 468:	8f 62       	ori	r24, 0x2F	; 47
 46a:	84 b9       	out	0x04, r24	; 4
 46c:	17 b8       	out	0x07, r1	; 7
 46e:	8a b1       	in	r24, 0x0a	; 10
 470:	88 6d       	ori	r24, 0xD8	; 216
 472:	8a b9       	out	0x0a, r24	; 10
 474:	41 e0       	ldi	r20, 0x01	; 1
 476:	61 e0       	ldi	r22, 0x01	; 1
 478:	81 e0       	ldi	r24, 0x01	; 1
 47a:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 47e:	41 e0       	ldi	r20, 0x01	; 1
 480:	62 e0       	ldi	r22, 0x02	; 2
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 488:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <IRQ_Timer1_Init>
 48c:	87 e6       	ldi	r24, 0x67	; 103
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	0e 94 fd 02 	call	0x5fa	; 0x5fa <USART_Init>
 494:	0e 94 23 03 	call	0x646	; 0x646 <SPI_Init>
 498:	41 e0       	ldi	r20, 0x01	; 1
 49a:	64 e0       	ldi	r22, 0x04	; 4
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 4a2:	40 e0       	ldi	r20, 0x00	; 0
 4a4:	66 e0       	ldi	r22, 0x06	; 6
 4a6:	83 e0       	ldi	r24, 0x03	; 3
 4a8:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 4ac:	41 e0       	ldi	r20, 0x01	; 1
 4ae:	63 e0       	ldi	r22, 0x03	; 3
 4b0:	83 e0       	ldi	r24, 0x03	; 3
 4b2:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 4b6:	41 e0       	ldi	r20, 0x01	; 1
 4b8:	67 e0       	ldi	r22, 0x07	; 7
 4ba:	83 e0       	ldi	r24, 0x03	; 3
 4bc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 4c0:	10 92 66 01 	sts	0x0166, r1	; 0x800166 <Pair_Status>
 4c4:	78 94       	sei
 4c6:	80 e0       	ldi	r24, 0x00	; 0
 4c8:	08 95       	ret

Disassembly of section .text.main:

0000028c <main>:
 28c:	cf 93       	push	r28
 28e:	df 93       	push	r29
 290:	cd b7       	in	r28, 0x3d	; 61
 292:	de b7       	in	r29, 0x3e	; 62
 294:	a2 97       	sbiw	r28, 0x22	; 34
 296:	0f b6       	in	r0, 0x3f	; 63
 298:	f8 94       	cli
 29a:	de bf       	out	0x3e, r29	; 62
 29c:	0f be       	out	0x3f, r0	; 63
 29e:	cd bf       	out	0x3d, r28	; 61
 2a0:	2f ef       	ldi	r18, 0xFF	; 255
 2a2:	81 ee       	ldi	r24, 0xE1	; 225
 2a4:	94 e0       	ldi	r25, 0x04	; 4
 2a6:	21 50       	subi	r18, 0x01	; 1
 2a8:	80 40       	sbci	r24, 0x00	; 0
 2aa:	90 40       	sbci	r25, 0x00	; 0
 2ac:	e1 f7       	brne	.-8      	; 0x2a6 <main+0x1a>
 2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <main+0x24>
 2b0:	00 00       	nop
 2b2:	0e 94 33 02 	call	0x466	; 0x466 <DeviceInit>
 2b6:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <InitError>
 2ba:	2e ec       	ldi	r18, 0xCE	; 206
 2bc:	30 e0       	ldi	r19, 0x00	; 0
 2be:	40 e0       	ldi	r20, 0x00	; 0
 2c0:	82 e2       	ldi	r24, 0x22	; 34
 2c2:	f9 01       	movw	r30, r18
 2c4:	de 01       	movw	r26, r28
 2c6:	11 96       	adiw	r26, 0x01	; 1
 2c8:	74 2f       	mov	r23, r20
 2ca:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <__movmemx_qi>
 2ce:	ce 01       	movw	r24, r28
 2d0:	01 96       	adiw	r24, 0x01	; 1
 2d2:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
 2d6:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <InitError>
 2da:	81 11       	cpse	r24, r1
 2dc:	0e c0       	rjmp	.+28     	; 0x2fa <main+0x6e>
 2de:	90 91 69 01 	lds	r25, 0x0169	; 0x800169 <InitOK>
 2e2:	91 30       	cpi	r25, 0x01	; 1
 2e4:	51 f4       	brne	.+20     	; 0x2fa <main+0x6e>
 2e6:	90 91 66 01 	lds	r25, 0x0166	; 0x800166 <Pair_Status>
 2ea:	91 30       	cpi	r25, 0x01	; 1
 2ec:	31 f4       	brne	.+12     	; 0x2fa <main+0x6e>
 2ee:	40 e0       	ldi	r20, 0x00	; 0
 2f0:	62 e0       	ldi	r22, 0x02	; 2
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 2f8:	ee cf       	rjmp	.-36     	; 0x2d6 <main+0x4a>
 2fa:	81 11       	cpse	r24, r1
 2fc:	ec cf       	rjmp	.-40     	; 0x2d6 <main+0x4a>
 2fe:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <InitOK>
 302:	81 30       	cpi	r24, 0x01	; 1
 304:	41 f7       	brne	.-48     	; 0x2d6 <main+0x4a>
 306:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <Pair_Status>
 30a:	81 11       	cpse	r24, r1
 30c:	e4 cf       	rjmp	.-56     	; 0x2d6 <main+0x4a>
 30e:	40 e0       	ldi	r20, 0x00	; 0
 310:	61 e0       	ldi	r22, 0x01	; 1
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 318:	2f ef       	ldi	r18, 0xFF	; 255
 31a:	83 ed       	ldi	r24, 0xD3	; 211
 31c:	90 e3       	ldi	r25, 0x30	; 48
 31e:	21 50       	subi	r18, 0x01	; 1
 320:	80 40       	sbci	r24, 0x00	; 0
 322:	90 40       	sbci	r25, 0x00	; 0
 324:	e1 f7       	brne	.-8      	; 0x31e <main+0x92>
 326:	00 c0       	rjmp	.+0      	; 0x328 <main+0x9c>
 328:	00 00       	nop
 32a:	83 e0       	ldi	r24, 0x03	; 3
 32c:	0e 94 65 02 	call	0x4ca	; 0x4ca <SPI_test>
 330:	86 b1       	in	r24, 0x06	; 6
 332:	d1 cf       	rjmp	.-94     	; 0x2d6 <main+0x4a>

Disassembly of section .text.__vector_1:

000005e2 <__vector_1>:
		
}

// Interrupt for RF RX data
ISR(INT0_vect)
{
 5e2:	1f 92       	push	r1
 5e4:	0f 92       	push	r0
 5e6:	0f b6       	in	r0, 0x3f	; 63
 5e8:	0f 92       	push	r0
 5ea:	11 24       	eor	r1, r1
	cli();
 5ec:	f8 94       	cli
	
	
	
	sei();
 5ee:	78 94       	sei
}
 5f0:	0f 90       	pop	r0
 5f2:	0f be       	out	0x3f, r0	; 63
 5f4:	0f 90       	pop	r0
 5f6:	1f 90       	pop	r1
 5f8:	18 95       	reti

Disassembly of section .text.SPI_Init:

00000646 <SPI_Init>:

void SPI_Init()
{
	// CS, MOSI, SCK output; MISO input -> Set in main
    // enable and set SPI
    SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
 646:	83 e5       	ldi	r24, 0x53	; 83
 648:	8c bd       	out	0x2c, r24	; 44
 64a:	08 95       	ret

Disassembly of section .text.SPI_Transmit:

0000063a <SPI_Transmit>:
}

uint8_t SPI_Transmit(unsigned char data)
{
	SPDR = data; // load data in register
 63a:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1 << SPIF))); // Wait for transmission
 63c:	0d b4       	in	r0, 0x2d	; 45
 63e:	07 fe       	sbrs	r0, 7
 640:	fd cf       	rjmp	.-6      	; 0x63c <SPI_Transmit+0x2>
	return SPDR;
 642:	8e b5       	in	r24, 0x2e	; 46
}
 644:	08 95       	ret

Disassembly of section .text.SPI_test:

000004ca <SPI_test>:
	
	
}

uint8_t SPI_test(uint8_t CS_Pin)
{
 4ca:	cf 93       	push	r28
 4cc:	df 93       	push	r29
 4ce:	c8 2f       	mov	r28, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4d0:	83 e0       	ldi	r24, 0x03	; 3
 4d2:	8a 95       	dec	r24
 4d4:	f1 f7       	brne	.-4      	; 0x4d2 <SPI_test+0x8>
 4d6:	00 00       	nop
	_delay_us(10);
	GPIO_PIN_Write(GPIO_PORT_D,CS_Pin,GPIO_LOW); //CS low to enable device
 4d8:	40 e0       	ldi	r20, 0x00	; 0
 4da:	6c 2f       	mov	r22, r28
 4dc:	83 e0       	ldi	r24, 0x03	; 3
 4de:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
 4e2:	83 e0       	ldi	r24, 0x03	; 3
 4e4:	8a 95       	dec	r24
 4e6:	f1 f7       	brne	.-4      	; 0x4e4 <SPI_test+0x1a>
 4e8:	00 00       	nop
	_delay_us(10);
	SPI_Transmit(R_REGISTER + STATUS);
 4ea:	87 e0       	ldi	r24, 0x07	; 7
 4ec:	0e 94 1d 03 	call	0x63a	; 0x63a <SPI_Transmit>
 4f0:	83 e0       	ldi	r24, 0x03	; 3
 4f2:	8a 95       	dec	r24
 4f4:	f1 f7       	brne	.-4      	; 0x4f2 <SPI_test+0x28>
 4f6:	00 00       	nop
	_delay_us(10);
	uint8_t ret = SPI_Transmit(NOP);
 4f8:	8f ef       	ldi	r24, 0xFF	; 255
 4fa:	0e 94 1d 03 	call	0x63a	; 0x63a <SPI_Transmit>
 4fe:	d8 2f       	mov	r29, r24
 500:	83 e0       	ldi	r24, 0x03	; 3
 502:	8a 95       	dec	r24
 504:	f1 f7       	brne	.-4      	; 0x502 <SPI_test+0x38>
 506:	00 00       	nop
	_delay_us(10);
	GPIO_PIN_Write(GPIO_PORT_D,CS_Pin,GPIO_HIGH); //CS low to disable device
 508:	41 e0       	ldi	r20, 0x01	; 1
 50a:	6c 2f       	mov	r22, r28
 50c:	83 e0       	ldi	r24, 0x03	; 3
 50e:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <GPIO_PIN_Write>
	
	return ret;	
}
 512:	8d 2f       	mov	r24, r29
 514:	df 91       	pop	r29
 516:	cf 91       	pop	r28
 518:	08 95       	ret

Disassembly of section .text.USART_Init:

000005fa <USART_Init>:
uint8_t Data_Count = 0;
uint8_t USART_DATA_RAW_Recieve[100] = {};

void USART_Init(unsigned int presc)
{
	UBRR0H = (unsigned char)(presc>>8);
 5fa:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = (unsigned char)presc;
 5fe:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0B = (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0) | (1<<TXCIE0);
 602:	88 ed       	ldi	r24, 0xD8	; 216
 604:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C = USART_MODE | USART_PARITY_MODE | USART_STOP_BIT | USART_DATA_BIT;
 608:	86 e0       	ldi	r24, 0x06	; 6
 60a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
 60e:	08 95       	ret

Disassembly of section .text.__vector_20:

00000626 <__vector_20>:
}

// USART Transmit
ISR(USART_TX_vect)
{
 626:	1f 92       	push	r1
 628:	0f 92       	push	r0
 62a:	0f b6       	in	r0, 0x3f	; 63
 62c:	0f 92       	push	r0
 62e:	11 24       	eor	r1, r1
	// TRANSMIT...
}
 630:	0f 90       	pop	r0
 632:	0f be       	out	0x3f, r0	; 63
 634:	0f 90       	pop	r0
 636:	1f 90       	pop	r1
 638:	18 95       	reti

Disassembly of section .text.USART_DATA_Transmit:

00000568 <USART_DATA_Transmit>:
		// SEND TO DRONE
	}
}

void USART_DATA_Transmit(uint8_t data[100])
{
 568:	bc 01       	movw	r22, r24
	for(int i = 0; i<100;i++){
 56a:	20 e0       	ldi	r18, 0x00	; 0
 56c:	30 e0       	ldi	r19, 0x00	; 0
 56e:	14 c0       	rjmp	.+40     	; 0x598 <USART_DATA_Transmit+0x30>
		if (data[i] == 'f' && data[i+1] == 'f'){
 570:	fb 01       	movw	r30, r22
 572:	e2 0f       	add	r30, r18
 574:	f3 1f       	adc	r31, r19
 576:	40 81       	ld	r20, Z
 578:	46 36       	cpi	r20, 0x66	; 102
 57a:	31 f4       	brne	.+12     	; 0x588 <USART_DATA_Transmit+0x20>
 57c:	fb 01       	movw	r30, r22
 57e:	e2 0f       	add	r30, r18
 580:	f3 1f       	adc	r31, r19
 582:	81 81       	ldd	r24, Z+1	; 0x01
 584:	86 36       	cpi	r24, 0x66	; 102
 586:	59 f0       	breq	.+22     	; 0x59e <USART_DATA_Transmit+0x36>
			break;
		}else{
			while ( !( UCSR0A & (1<<UDRE0)) );		
 588:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 58c:	95 ff       	sbrs	r25, 5
 58e:	fc cf       	rjmp	.-8      	; 0x588 <USART_DATA_Transmit+0x20>
			UDR0 = data[i]; // TransmitDataBuffer
 590:	40 93 c6 00 	sts	0x00C6, r20	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	}
}

void USART_DATA_Transmit(uint8_t data[100])
{
	for(int i = 0; i<100;i++){
 594:	2f 5f       	subi	r18, 0xFF	; 255
 596:	3f 4f       	sbci	r19, 0xFF	; 255
 598:	24 36       	cpi	r18, 0x64	; 100
 59a:	31 05       	cpc	r19, r1
 59c:	4c f3       	brlt	.-46     	; 0x570 <USART_DATA_Transmit+0x8>
 59e:	08 95       	ret

Disassembly of section .text.USART_RX_DATA_Decode:

000000f0 <USART_RX_DATA_Decode>:
	}
}

/* USART decode and communication */
void USART_RX_DATA_Decode(uint8_t data[100])
{
  f0:	0f 93       	push	r16
  f2:	1f 93       	push	r17
  f4:	cf 93       	push	r28
  f6:	df 93       	push	r29
  f8:	cd b7       	in	r28, 0x3d	; 61
  fa:	de b7       	in	r29, 0x3e	; 62
  fc:	c4 56       	subi	r28, 0x64	; 100
  fe:	d1 09       	sbc	r29, r1
 100:	0f b6       	in	r0, 0x3f	; 63
 102:	f8 94       	cli
 104:	de bf       	out	0x3e, r29	; 62
 106:	0f be       	out	0x3f, r0	; 63
 108:	cd bf       	out	0x3d, r28	; 61
 10a:	8c 01       	movw	r16, r24
	uint8_t responsePacket[100] = {};
 10c:	fe 01       	movw	r30, r28
 10e:	31 96       	adiw	r30, 0x01	; 1
 110:	84 e6       	ldi	r24, 0x64	; 100
 112:	df 01       	movw	r26, r30
 114:	1d 92       	st	X+, r1
 116:	8a 95       	dec	r24
 118:	e9 f7       	brne	.-6      	; 0x114 <USART_RX_DATA_Decode+0x24>
	
	if (data[0] == '0')			// LINK command
 11a:	f8 01       	movw	r30, r16
 11c:	80 81       	ld	r24, Z
 11e:	80 33       	cpi	r24, 0x30	; 48
 120:	09 f0       	breq	.+2      	; 0x124 <USART_RX_DATA_Decode+0x34>
 122:	40 c0       	rjmp	.+128    	; 0x1a4 <USART_RX_DATA_Decode+0xb4>
	{
		if (data[1] == '1')					//setup
 124:	81 81       	ldd	r24, Z+1	; 0x01
 126:	81 33       	cpi	r24, 0x31	; 49
 128:	a9 f4       	brne	.+42     	; 0x154 <USART_RX_DATA_Decode+0x64>
			uint8_t baud3 = (char)((USART_BAUD-baud1*100000-baud2*10000)/1000);
			uint8_t baud4 = (char)((USART_BAUD-baud1*100000-baud2*10000-baud3*1000)/100);
			uint8_t baud5 = (char)((USART_BAUD-baud1*100000-baud2*10000-baud3*1000-baud4*100)/10);
			uint8_t baud6 = (char)((USART_BAUD-baud1*100000-baud2*10000-baud3*1000-baud4*100-baud5*10)%10);
			
			responsePacket[0] = (char)(CODE_ID_LINK_RESPONSE/10+48);
 12a:	80 e3       	ldi	r24, 0x30	; 48
 12c:	89 83       	std	Y+1, r24	; 0x01
			responsePacket[1] = (char)(CODE_ID_LINK_RESPONSE%10+48);
 12e:	94 e3       	ldi	r25, 0x34	; 52
 130:	9a 83       	std	Y+2, r25	; 0x02
			responsePacket[2] = ',';
 132:	9c e2       	ldi	r25, 0x2C	; 44
 134:	9b 83       	std	Y+3, r25	; 0x03
			responsePacket[3] = (char)(baud1+48);
 136:	8c 83       	std	Y+4, r24	; 0x04
			responsePacket[4] = (char)(baud2+48);
 138:	8d 83       	std	Y+5, r24	; 0x05
			responsePacket[5] = (char)(baud3+48);
 13a:	99 e3       	ldi	r25, 0x39	; 57
 13c:	9e 83       	std	Y+6, r25	; 0x06
			responsePacket[6] = (char)(baud4+48);
 13e:	96 e3       	ldi	r25, 0x36	; 54
 140:	9f 83       	std	Y+7, r25	; 0x07
			responsePacket[7] = (char)(baud5+48);
 142:	88 87       	std	Y+8, r24	; 0x08
			responsePacket[8] = (char)(baud6+48);
 144:	89 87       	std	Y+9, r24	; 0x09
			responsePacket[9] = 'f';
 146:	86 e6       	ldi	r24, 0x66	; 102
 148:	8a 87       	std	Y+10, r24	; 0x0a
			responsePacket[10] = 'f';
 14a:	8b 87       	std	Y+11, r24	; 0x0b
						
			USART_DATA_Transmit(responsePacket);
 14c:	ce 01       	movw	r24, r28
 14e:	01 96       	adiw	r24, 0x01	; 1
 150:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
		}
		
		if (data[1] == '2')					// Errors (NOT PROGRAMED YET)
 154:	d8 01       	movw	r26, r16
 156:	11 96       	adiw	r26, 0x01	; 1
 158:	8c 91       	ld	r24, X
 15a:	82 33       	cpi	r24, 0x32	; 50
 15c:	79 f4       	brne	.+30     	; 0x17c <USART_RX_DATA_Decode+0x8c>
		{
			responsePacket[0] = (char)(CODE_ID_LINK_RESPONSE/10+48);
 15e:	80 e3       	ldi	r24, 0x30	; 48
 160:	89 83       	std	Y+1, r24	; 0x01
			responsePacket[1] = (char)(CODE_ID_LINK_RESPONSE%10+48);
 162:	94 e3       	ldi	r25, 0x34	; 52
 164:	9a 83       	std	Y+2, r25	; 0x02
			responsePacket[2] = ',';
 166:	9c e2       	ldi	r25, 0x2C	; 44
 168:	9b 83       	std	Y+3, r25	; 0x03
			responsePacket[3] = '0';
 16a:	8c 83       	std	Y+4, r24	; 0x04
			responsePacket[4] = '0';
 16c:	8d 83       	std	Y+5, r24	; 0x05
			responsePacket[5] = 'f';
 16e:	86 e6       	ldi	r24, 0x66	; 102
 170:	8e 83       	std	Y+6, r24	; 0x06
			responsePacket[6] = 'f';
 172:	8f 83       	std	Y+7, r24	; 0x07
			
			USART_DATA_Transmit(responsePacket);
 174:	ce 01       	movw	r24, r28
 176:	01 96       	adiw	r24, 0x01	; 1
 178:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
		}
		
		if (data[1] == '3')					// Pair
 17c:	f8 01       	movw	r30, r16
 17e:	81 81       	ldd	r24, Z+1	; 0x01
 180:	83 33       	cpi	r24, 0x33	; 51
 182:	21 f5       	brne	.+72     	; 0x1cc <USART_RX_DATA_Decode+0xdc>
		{
			
			responsePacket[0] = (char)(CODE_ID_LINK_RESPONSE/10+48);
 184:	80 e3       	ldi	r24, 0x30	; 48
 186:	89 83       	std	Y+1, r24	; 0x01
			responsePacket[1] = (char)(CODE_ID_LINK_RESPONSE%10+48);
 188:	84 e3       	ldi	r24, 0x34	; 52
 18a:	8a 83       	std	Y+2, r24	; 0x02
			responsePacket[2] = ',';
 18c:	8c e2       	ldi	r24, 0x2C	; 44
 18e:	8b 83       	std	Y+3, r24	; 0x03
			responsePacket[3] = (char)(CODE_ID_PAIR);
 190:	83 e0       	ldi	r24, 0x03	; 3
 192:	8c 83       	std	Y+4, r24	; 0x04
			responsePacket[4] = 'f';
 194:	86 e6       	ldi	r24, 0x66	; 102
 196:	8d 83       	std	Y+5, r24	; 0x05
			responsePacket[5] = 'f';	
 198:	8e 83       	std	Y+6, r24	; 0x06
					
			USART_DATA_Transmit(responsePacket);
 19a:	ce 01       	movw	r24, r28
 19c:	01 96       	adiw	r24, 0x01	; 1
 19e:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
 1a2:	14 c0       	rjmp	.+40     	; 0x1cc <USART_RX_DATA_Decode+0xdc>
		}
	}
	else if (data[0] == '1')		// DRONE command
 1a4:	81 33       	cpi	r24, 0x31	; 49
 1a6:	29 f4       	brne	.+10     	; 0x1b2 <USART_RX_DATA_Decode+0xc2>
	{
		USART_DATA_Transmit(responsePacket);
 1a8:	ce 01       	movw	r24, r28
 1aa:	01 96       	adiw	r24, 0x01	; 1
 1ac:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
 1b0:	0d c0       	rjmp	.+26     	; 0x1cc <USART_RX_DATA_Decode+0xdc>
	}
	else if (data[0] == '2')		// DRONE FLIGHT command
 1b2:	82 33       	cpi	r24, 0x32	; 50
 1b4:	29 f4       	brne	.+10     	; 0x1c0 <USART_RX_DATA_Decode+0xd0>
	{
		USART_DATA_Transmit(responsePacket);
 1b6:	ce 01       	movw	r24, r28
 1b8:	01 96       	adiw	r24, 0x01	; 1
 1ba:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
 1be:	06 c0       	rjmp	.+12     	; 0x1cc <USART_RX_DATA_Decode+0xdc>
	}
	else if(data[0] == '3')			// DRONE AFTER FLIGHT command
 1c0:	83 33       	cpi	r24, 0x33	; 51
 1c2:	21 f4       	brne	.+8      	; 0x1cc <USART_RX_DATA_Decode+0xdc>
	{
		USART_DATA_Transmit(responsePacket);
 1c4:	ce 01       	movw	r24, r28
 1c6:	01 96       	adiw	r24, 0x01	; 1
 1c8:	0e 94 b4 02 	call	0x568	; 0x568 <USART_DATA_Transmit>
	}
	else
	{
		// SEND TO DRONE
	}
}
 1cc:	cc 59       	subi	r28, 0x9C	; 156
 1ce:	df 4f       	sbci	r29, 0xFF	; 255
 1d0:	0f b6       	in	r0, 0x3f	; 63
 1d2:	f8 94       	cli
 1d4:	de bf       	out	0x3e, r29	; 62
 1d6:	0f be       	out	0x3f, r0	; 63
 1d8:	cd bf       	out	0x3d, r28	; 61
 1da:	df 91       	pop	r29
 1dc:	cf 91       	pop	r28
 1de:	1f 91       	pop	r17
 1e0:	0f 91       	pop	r16
 1e2:	08 95       	ret

Disassembly of section .text.__vector_18:

000003d2 <__vector_18>:
	// TRANSMIT...
}

// USART Receive
ISR(USART_RX_vect)
{
 3d2:	1f 92       	push	r1
 3d4:	0f 92       	push	r0
 3d6:	0f b6       	in	r0, 0x3f	; 63
 3d8:	0f 92       	push	r0
 3da:	11 24       	eor	r1, r1
 3dc:	2f 93       	push	r18
 3de:	3f 93       	push	r19
 3e0:	4f 93       	push	r20
 3e2:	5f 93       	push	r21
 3e4:	6f 93       	push	r22
 3e6:	7f 93       	push	r23
 3e8:	8f 93       	push	r24
 3ea:	9f 93       	push	r25
 3ec:	af 93       	push	r26
 3ee:	bf 93       	push	r27
 3f0:	ef 93       	push	r30
 3f2:	ff 93       	push	r31
	RecievedDataBuffer = UDR0; // incoming data  UCSR0B
 3f4:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
 3f8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>

	// Read data and save in buffer. If sequence of dual f is detected the entire data is received
	if (USART_DATA_RAW_Recieve[Data_Count - 1] == 'f' && RecievedDataBuffer == 'f'){
 3fc:	20 91 6c 01 	lds	r18, 0x016C	; 0x80016c <Data_Count>
 400:	82 2f       	mov	r24, r18
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	fc 01       	movw	r30, r24
 406:	ef 5f       	subi	r30, 0xFF	; 255
 408:	fe 4f       	sbci	r31, 0xFE	; 254
 40a:	30 81       	ld	r19, Z
 40c:	36 36       	cpi	r19, 0x66	; 102
 40e:	89 f4       	brne	.+34     	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
 410:	30 91 00 01 	lds	r19, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 414:	36 36       	cpi	r19, 0x66	; 102
 416:	69 f4       	brne	.+26     	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
		USART_DATA_RAW_Recieve[Data_Count] = RecievedDataBuffer; // save last byte
 418:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 41c:	fc 01       	movw	r30, r24
 41e:	ee 5f       	subi	r30, 0xFE	; 254
 420:	fe 4f       	sbci	r31, 0xFE	; 254
 422:	20 83       	st	Z, r18
		Data_Count = 0;		// reset data counter for saving in array
 424:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <Data_Count>
		USART_RX_DATA_Decode(USART_DATA_RAW_Recieve);
 428:	82 e0       	ldi	r24, 0x02	; 2
 42a:	91 e0       	ldi	r25, 0x01	; 1
 42c:	0e 94 78 00 	call	0xf0	; 0xf0 <USART_RX_DATA_Decode>
 430:	09 c0       	rjmp	.+18     	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
	}
	else
	{
		// Save received data and increase counter
		USART_DATA_RAW_Recieve[Data_Count] = RecievedDataBuffer;
 432:	30 91 00 01 	lds	r19, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 436:	fc 01       	movw	r30, r24
 438:	ee 5f       	subi	r30, 0xFE	; 254
 43a:	fe 4f       	sbci	r31, 0xFE	; 254
 43c:	30 83       	st	Z, r19
		Data_Count++;
 43e:	2f 5f       	subi	r18, 0xFF	; 255
 440:	20 93 6c 01 	sts	0x016C, r18	; 0x80016c <Data_Count>
	}
}
 444:	ff 91       	pop	r31
 446:	ef 91       	pop	r30
 448:	bf 91       	pop	r27
 44a:	af 91       	pop	r26
 44c:	9f 91       	pop	r25
 44e:	8f 91       	pop	r24
 450:	7f 91       	pop	r23
 452:	6f 91       	pop	r22
 454:	5f 91       	pop	r21
 456:	4f 91       	pop	r20
 458:	3f 91       	pop	r19
 45a:	2f 91       	pop	r18
 45c:	0f 90       	pop	r0
 45e:	0f be       	out	0x3f, r0	; 63
 460:	0f 90       	pop	r0
 462:	1f 90       	pop	r1
 464:	18 95       	reti

Disassembly of section .text.libgcc:

000005c8 <__movmemx_qi>:
 5c8:	99 27       	eor	r25, r25

000005ca <__movmemx_hi>:
 5ca:	77 fd       	sbrc	r23, 7
 5cc:	05 c0       	rjmp	.+10     	; 0x5d8 <__movmemx_hi+0xe>
 5ce:	05 90       	lpm	r0, Z+
 5d0:	0d 92       	st	X+, r0
 5d2:	01 97       	sbiw	r24, 0x01	; 1
 5d4:	e1 f7       	brne	.-8      	; 0x5ce <__movmemx_hi+0x4>
 5d6:	08 95       	ret
 5d8:	01 90       	ld	r0, Z+
 5da:	0d 92       	st	X+, r0
 5dc:	01 97       	sbiw	r24, 0x01	; 1
 5de:	e1 f7       	brne	.-8      	; 0x5d8 <__movmemx_hi+0xe>
 5e0:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00000654 <_fini>:
 654:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000656 <__funcs_on_exit>:
 656:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000658 <__simulator_exit>:
 658:	08 95       	ret

Disassembly of section .text.exit:

00000610 <exit>:
 610:	ec 01       	movw	r28, r24
 612:	0e 94 2b 03 	call	0x656	; 0x656 <__funcs_on_exit>
 616:	0e 94 2a 03 	call	0x654	; 0x654 <_fini>
 61a:	ce 01       	movw	r24, r28
 61c:	0e 94 2c 03 	call	0x658	; 0x658 <__simulator_exit>
 620:	ce 01       	movw	r24, r28
 622:	0e 94 28 03 	call	0x650	; 0x650 <_Exit>

Disassembly of section .text._Exit:

00000650 <_Exit>:
 650:	0e 94 65 00 	call	0xca	; 0xca <_exit>
